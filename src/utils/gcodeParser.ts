import JSZip from 'jszip'

export interface GcodeMetadata {
  printer_model?: string
  printer_brand?: string
  material_name?: string
  material_type?: string
  print_settings_id?: string
  print_settings_name?: string
  printer_settings_id?: string
  application?: string
  creation_date?: string
  designer_user_id?: string
  nozzle_diameter?: string
  is_automatic_profile?: string
  [key: string]: string | undefined
}

export interface ConcatenationCandidate {
  ordineIds: number[]
  gcodeIds: number[]
  stampanteId: string // Nome della stampante invece dell'ID numerico
  materialName: string
  printSettingsName: string
  totalQuantity: number
  isSameGcode: boolean
}

export interface GcodeAnalysis {
  tempo_stampa_min: number | null
  peso_grammi: number
  materiale?: string
  stampante?: string
  layer_height?: number
  infill_percentage?: number
  print_speed?: number
  bed_temperature?: number
  nozzle_temperature?: number
  total_layers?: number
  print_volume_cm3?: number
  estimated_cost?: number
}

export interface GcodeStats {
  totalLines: number
  g1Commands: number
  g0Commands: number
  m104Commands: number
  m140Commands: number
  m190Commands: number
  m109Commands: number
  m82Commands: number
  m83Commands: number
  m84Commands: number
}

export class GcodeParser {
  private content: string
  private lines: string[]
  private stats: GcodeStats

  constructor(content: string) {
    this.content = content
    this.lines = content.split('\n')
    this.stats = this.analyzeStats()
  }

  private analyzeStats(): GcodeStats {
    const stats: GcodeStats = {
      totalLines: this.lines.length,
      g1Commands: 0,
      g0Commands: 0,
      m104Commands: 0,
      m140Commands: 0,
      m190Commands: 0,
      m109Commands: 0,
      m82Commands: 0,
      m83Commands: 0,
      m84Commands: 0
    }

    for (const line of this.lines) {
      const trimmedLine = line.trim().toUpperCase()
      if (trimmedLine.startsWith('G1')) stats.g1Commands++
      if (trimmedLine.startsWith('G0')) stats.g0Commands++
      if (trimmedLine.includes('M104')) stats.m104Commands++
      if (trimmedLine.includes('M140')) stats.m140Commands++
      if (trimmedLine.includes('M190')) stats.m190Commands++
      if (trimmedLine.includes('M109')) stats.m109Commands++
      if (trimmedLine.includes('M82')) stats.m82Commands++
      if (trimmedLine.includes('M83')) stats.m83Commands++
      if (trimmedLine.includes('M84')) stats.m84Commands++
    }

    return stats
  }

  public analyze(): GcodeAnalysis {
    const analysis: GcodeAnalysis = {
      tempo_stampa_min: this.calculatePrintTime() || null,
      peso_grammi: this.calculateWeight(),
      materiale: this.extractMaterial(),
      stampante: this.extractPrinterName(),
      layer_height: this.extractLayerHeight(),
      infill_percentage: this.extractInfillPercentage(),
      print_speed: this.extractPrintSpeed(),
      bed_temperature: this.extractBedTemperature(),
      nozzle_temperature: this.extractNozzleTemperature(),
      total_layers: this.calculateTotalLayers(),
      print_volume_cm3: this.calculatePrintVolume(),
      estimated_cost: 0 // Calcolato in base a peso e materiale
    }

    // Calcola costo stimato
    analysis.estimated_cost = this.calculateEstimatedCost(analysis.peso_grammi, analysis.materiale)

    return analysis
  }

  private calculatePrintTime(): number | null {
    // Cerca righe che contengono informazioni sul tempo
    const lines = this.content.split('\n')
    
    // Controlla se √® un file PrusaSlicer
    const isPrusaSlicer = lines.some(line => line.includes('generated by PrusaSlicer'))
    
    // Se √® PrusaSlicer, cerca nelle ultime 400 righe, altrimenti nelle prime 50
    const searchLines = isPrusaSlicer ? lines.slice(-400) : lines.slice(0, 50)
    
    // Debug: mostra le righe di ricerca
    const debugLines = searchLines.join('\n')
    console.log(`üîç Righe di ricerca (${isPrusaSlicer ? 'ultime 400' : 'prime 50'}):`, debugLines)
    
    for (const line of searchLines) {
      const trimmedLine = line.trim()
      
      // Debug: mostra tutte le righe che contengono "time" o "TIME"
      if (trimmedLine.toLowerCase().includes('time')) {
        console.log('üîç Riga con "time" trovata:', trimmedLine)
      }
      
      // Pattern per BambuStudio: "model printing time: 40m 2s" o "1h 1m 23s" o "1d 2h 30m 15s"
      if (trimmedLine.includes('model printing time:')) {
        console.log('üîç Trovata riga model printing time:', trimmedLine)
        
        // Pattern per formato con giorni: "1d 2h 30m 15s"
        const timeMatchWithDays = trimmedLine.match(/model printing time:\s*(\d+)d\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithDays) {
          const days = parseInt(timeMatchWithDays[1])
          const hours = parseInt(timeMatchWithDays[2])
          const minutes = parseInt(timeMatchWithDays[3])
          const seconds = parseInt(timeMatchWithDays[4])
          const totalMinutes = Math.round((days * 86400 + hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da model printing time (con giorni):', days, 'd', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato con ore: "1h 1m 23s"
        const timeMatchWithHours = trimmedLine.match(/model printing time:\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithHours) {
          const hours = parseInt(timeMatchWithHours[1])
          const minutes = parseInt(timeMatchWithHours[2])
          const seconds = parseInt(timeMatchWithHours[3])
          const totalMinutes = Math.round((hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da model printing time (con ore):', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato senza ore: "40m 2s"
        const timeMatchWithoutHours = trimmedLine.match(/model printing time:\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithoutHours) {
          const minutes = parseInt(timeMatchWithoutHours[1])
          const seconds = parseInt(timeMatchWithoutHours[2])
          const totalMinutes = Math.round((minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da model printing time (senza ore):', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
          } else {
          console.log('‚ùå Pattern model printing time non matchato su:', trimmedLine)
        }
      }
      
      // Pattern per BambuStudio: "total estimated time: 41m 50s" o "1h 3m 11s" o "1d 2h 30m 15s"
      if (trimmedLine.includes('total estimated time:')) {
        console.log('üîç Trovata riga total estimated time:', trimmedLine)
        
        // Pattern per formato con giorni: "1d 2h 30m 15s"
        const timeMatchWithDays = trimmedLine.match(/total estimated time:\s*(\d+)d\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithDays) {
          const days = parseInt(timeMatchWithDays[1])
          const hours = parseInt(timeMatchWithDays[2])
          const minutes = parseInt(timeMatchWithDays[3])
          const seconds = parseInt(timeMatchWithDays[4])
          const totalMinutes = Math.round((days * 86400 + hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da total estimated time (con giorni):', days, 'd', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato con ore: "1h 3m 11s"
        const timeMatchWithHours = trimmedLine.match(/total estimated time:\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithHours) {
          const hours = parseInt(timeMatchWithHours[1])
          const minutes = parseInt(timeMatchWithHours[2])
          const seconds = parseInt(timeMatchWithHours[3])
          const totalMinutes = Math.round((hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da total estimated time (con ore):', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato senza ore: "41m 50s"
        const timeMatchWithoutHours = trimmedLine.match(/total estimated time:\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithoutHours) {
          const minutes = parseInt(timeMatchWithoutHours[1])
          const seconds = parseInt(timeMatchWithoutHours[2])
          const totalMinutes = Math.round((minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da total estimated time (senza ore):', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        } else {
          console.log('‚ùå Pattern total estimated time non matchato su:', trimmedLine)
        }
      }
      
      // Pattern pi√π flessibile per BambuStudio: cerca qualsiasi tempo in formato "Xd Yh Zm Ws" o "Xh Ym Zs" o "Xm Ys"
      if (trimmedLine.includes('time:') && (trimmedLine.includes('m') && trimmedLine.includes('s'))) {
        console.log('üîç Trovata riga con tempo generico:', trimmedLine)
        
        // Pattern per formato con giorni: "1d 2h 30m 15s"
        const timeMatchWithDays = trimmedLine.match(/(\d+)d\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithDays) {
          const days = parseInt(timeMatchWithDays[1])
          const hours = parseInt(timeMatchWithDays[2])
          const minutes = parseInt(timeMatchWithDays[3])
          const seconds = parseInt(timeMatchWithDays[4])
          const totalMinutes = Math.round((days * 86400 + hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da pattern generico (con giorni):', days, 'd', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato con ore: "1h 1m 23s"
        const timeMatchWithHours = trimmedLine.match(/(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithHours) {
          const hours = parseInt(timeMatchWithHours[1])
          const minutes = parseInt(timeMatchWithHours[2])
          const seconds = parseInt(timeMatchWithHours[3])
          const totalMinutes = Math.round((hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da pattern generico (con ore):', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato senza ore: "Xm Ys"
        const timeMatchWithoutHours = trimmedLine.match(/(\d+)m\s*(\d+)s/)
        if (timeMatchWithoutHours) {
          const minutes = parseInt(timeMatchWithoutHours[1])
          const seconds = parseInt(timeMatchWithoutHours[2])
          const totalMinutes = Math.round((minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da pattern generico (senza ore):', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
      }
      
      // Pattern standard per altri slicer
      if (trimmedLine.includes('TIME:')) {
        console.log('üîç Trovata riga TIME:', trimmedLine)
        const timeMatch = trimmedLine.match(/TIME:\s*(\d+)/)
        if (timeMatch) {
          const minutes = parseInt(timeMatch[1])
          console.log('‚è∞ Tempo estratto da TIME:', minutes, 'min')
          return minutes
        }
      }
      
      if (trimmedLine.includes('Estimated printing time:')) {
        console.log('üîç Trovata riga Estimated printing time:', trimmedLine)
        const timeMatch = trimmedLine.match(/Estimated printing time:\s*(\d+)/)
        if (timeMatch) {
          const minutes = parseInt(timeMatch[1])
          console.log('‚è∞ Tempo estratto da Estimated printing time:', minutes, 'min')
          return minutes
        }
      }
      
      // Pattern per PrusaSlicer: "Estimated printing time (normal mode): 1234"
      if (trimmedLine.includes('Estimated printing time (normal mode):')) {
        console.log('üîç Trovata riga Estimated printing time (normal mode):', trimmedLine)
        const timeMatch = trimmedLine.match(/Estimated printing time \(normal mode\):\s*(\d+)/)
        if (timeMatch) {
          const minutes = parseInt(timeMatch[1])
          console.log('‚è∞ Tempo estratto da Estimated printing time (normal mode):', minutes, 'min')
          return minutes
        }
      }
      
      // Pattern per PrusaSlicer: "estimated printing time (normal mode) = 1d 2h 15m 57s"
      if (trimmedLine.includes('estimated printing time (normal mode) =')) {
        console.log('üîç Trovata riga estimated printing time (normal mode) =', trimmedLine)
        
        // Pattern per formato con giorni: "1d 2h 15m 57s"
        const timeMatchWithDays = trimmedLine.match(/estimated printing time \(normal mode\)\s*=\s*(\d+)d\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithDays) {
          const days = parseInt(timeMatchWithDays[1])
          const hours = parseInt(timeMatchWithDays[2])
          const minutes = parseInt(timeMatchWithDays[3])
          const seconds = parseInt(timeMatchWithDays[4])
          const totalMinutes = Math.round((days * 86400 + hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da estimated printing time (con giorni):', days, 'd', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato con ore: "2h 15m 57s"
        const timeMatchWithHours = trimmedLine.match(/estimated printing time \(normal mode\)\s*=\s*(\d+)h\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithHours) {
          const hours = parseInt(timeMatchWithHours[1])
          const minutes = parseInt(timeMatchWithHours[2])
          const seconds = parseInt(timeMatchWithHours[3])
          const totalMinutes = Math.round((hours * 3600 + minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da estimated printing time (con ore):', hours, 'h', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
        
        // Pattern per formato senza ore: "15m 57s"
        const timeMatchWithoutHours = trimmedLine.match(/estimated printing time \(normal mode\)\s*=\s*(\d+)m\s*(\d+)s/)
        if (timeMatchWithoutHours) {
          const minutes = parseInt(timeMatchWithoutHours[1])
          const seconds = parseInt(timeMatchWithoutHours[2])
          const totalMinutes = Math.round((minutes * 60 + seconds) / 60)
          console.log('‚è∞ Tempo estratto da estimated printing time (senza ore):', minutes, 'm', seconds, 's ->', totalMinutes, 'min')
          return totalMinutes
        }
      }
      
      // Pattern per PrusaSlicer: "Print time: 1234"
      if (trimmedLine.includes('Print time:')) {
        console.log('üîç Trovata riga Print time:', trimmedLine)
        const timeMatch = trimmedLine.match(/Print time:\s*(\d+)/)
        if (timeMatch) {
          const minutes = parseInt(timeMatch[1])
          console.log('‚è∞ Tempo estratto da Print time:', minutes, 'min')
          return minutes
        }
      }
      
      // Pattern per PrusaSlicer: "TIME: 1234"
      if (trimmedLine.includes('TIME:')) {
        console.log('üîç Trovata riga TIME:', trimmedLine)
        const timeMatch = trimmedLine.match(/TIME:\s*(\d+)/)
        if (timeMatch) {
          const minutes = parseInt(timeMatch[1])
          console.log('‚è∞ Tempo estratto da TIME:', minutes, 'min')
          return minutes
        }
      }
    }

    console.log('‚ùå Nessun pattern tempo trovato, restituendo null')
    return null
  }

  private calculateWeight(): number {
    // Cerca righe che contengono informazioni sul peso
    const lines = this.content.split('\n')
    
    // Controlla se √® un file PrusaSlicer
    const isPrusaSlicer = lines.some(line => line.includes('generated by PrusaSlicer'))
    
    // Se √® PrusaSlicer, cerca nelle ultime 400 righe, altrimenti nelle prime 50
    const searchLines = isPrusaSlicer ? lines.slice(-400) : lines.slice(0, 50)
    
    for (const line of searchLines) {
      const trimmedLine = line.trim()
      
      // Pattern per BambuStudio: "total filament weight [g] : 23.74"
      if (trimmedLine.includes('total filament weight [g]')) {
        const weightMatch = trimmedLine.match(/total filament weight \[g\]\s*:\s*(\d+\.?\d*)/)
        if (weightMatch) {
          const weight = parseFloat(weightMatch[1])
          console.log('‚öñÔ∏è Peso estratto da total filament weight:', weight, 'g')
          return Math.round(weight)
        }
      }
      
      // Pattern per PrusaSlicer: "total filament used [g] = 2229.84"
      if (trimmedLine.includes('total filament used [g]')) {
        const weightMatch = trimmedLine.match(/total filament used \[g\]\s*=\s*(\d+\.?\d*)/)
        if (weightMatch) {
          const weight = parseFloat(weightMatch[1])
          console.log('‚öñÔ∏è Peso estratto da total filament used:', weight, 'g')
          return Math.round(weight)
        }
      }
      
      // Pattern per altri slicer
      if (trimmedLine.includes('Weight:') && trimmedLine.includes('g')) {
        const weightMatch = trimmedLine.match(/Weight:\s*(\d+\.?\d*)g/)
        if (weightMatch) {
          const weight = parseFloat(weightMatch[1])
          console.log('‚öñÔ∏è Peso estratto da Weight:', weight, 'g')
          return Math.round(weight)
        }
      }
      
      if (trimmedLine.includes('Filament used:') && trimmedLine.includes('m')) {
        const lengthMatch = trimmedLine.match(/Filament used:\s*(\d+\.?\d*)m/)
        if (lengthMatch) {
          const length = parseFloat(lengthMatch[1])
          // Converti lunghezza in peso (stima: 3g per metro di filamento 1.75mm)
          const weight = Math.round(length * 3)
          console.log('‚öñÔ∏è Peso calcolato da Filament used:', length, 'm ->', weight, 'g')
          return weight
        }
      }
    }

    // Stima basata su volume di stampa
    const volume = this.calculatePrintVolume()
    const density = 1.24 // g/cm¬≥ per PLA
    const estimatedWeight = Math.round(volume * density)
    console.log('‚öñÔ∏è Peso stimato da volume:', estimatedWeight, 'g')
    return estimatedWeight
  }

  private extractMaterial(): string | undefined {
    const lines = this.content.split('\n')
    
    // Controlla se √® un file PrusaSlicer
    const isPrusaSlicer = lines.some(line => line.includes('generated by PrusaSlicer'))
    
    // Se √® PrusaSlicer, cerca nelle ultime 400 righe, altrimenti nelle prime 50
    const searchLines = isPrusaSlicer ? lines.slice(-400) : lines.slice(0, 50)
    
    // Cerca prima filament_settings_id per PrusaSlicer
    if (isPrusaSlicer) {
      for (const line of searchLines) {
        const trimmedLine = line.trim()
        if (trimmedLine.includes('filament_settings_id =')) {
          const match = trimmedLine.match(/filament_settings_id = "([^"]+)";"([^"]+)"/)
          if (match) {
            // Prendi il primo materiale (prima del punto e virgola)
            const firstMaterial = match[1]
            // Estrai solo il nome del materiale (es. "PETG" da "PETG Fast-Forward...")
            const materialMatch = firstMaterial.match(/^([A-Z]+)/)
            if (materialMatch) {
              console.log('üîç Materiale estratto da filament_settings_id:', materialMatch[1])
              return materialMatch[1]
            }
          }
        }
      }
    }
    
    // Pattern generici per altri slicer
    const materialPatterns = [
      /;Filament type: (.+)/i,
      /;Material: (.+)/i,
      /;Filament: (.+)/i,
      /;PLA/i,
      /;ABS/i,
      /;PETG/i,
      /;TPU/i,
      /;filament_type = (.+)/i
    ]

    for (const pattern of materialPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        let material = match[1] || pattern.source.replace(/[;\/]/g, '')
        
        // Per filament_type, prendi solo il primo valore prima del punto e virgola
        if (pattern.source.includes('filament_type')) {
          material = material.split(';')[0]
        }
        
        return material.trim()
      }
    }

    return undefined
  }

  private extractPrinterName(): string | undefined {
    // Cerca righe che contengono informazioni sulla stampante
    const lines = this.content.split('\n')
    
    // Controlla se √® un file PrusaSlicer
    const isPrusaSlicer = lines.some(line => line.includes('generated by PrusaSlicer'))
    
    // Se √® PrusaSlicer, cerca nelle ultime 400 righe, altrimenti nelle prime 50
    const searchLines = isPrusaSlicer ? lines.slice(-400) : lines.slice(0, 50)
    
    for (const line of searchLines) {
      const trimmedLine = line.trim()
      
      // Pattern per BambuStudio: "printer_model: BL-P001"
      if (trimmedLine.includes('printer_model:')) {
        const printerMatch = trimmedLine.match(/printer_model:\s*(.+)/)
        if (printerMatch) {
          const printerName = printerMatch[1].trim()
          console.log('üñ®Ô∏è Stampante estratta da printer_model:', printerName)
          return printerName
        }
      }
      
      // Pattern per BambuStudio: "printer_brand: Bambu Lab"
      if (trimmedLine.includes('printer_brand:')) {
        const brandMatch = trimmedLine.match(/printer_brand:\s*(.+)/)
        if (brandMatch) {
          const brandName = brandMatch[1].trim()
          console.log('üñ®Ô∏è Brand stampante estratto:', brandName)
          return brandName
        }
      }
      
      // Pattern per inherits_group: "inherits_group": ["", "", "Bambu Lab X1 Carbon 0.6 nozzle"]
      if (trimmedLine.includes('inherits_group:')) {
        const inheritsMatch = trimmedLine.match(/inherits_group:\s*\[([^\]]+)\]/)
        if (inheritsMatch) {
          // Estrai il contenuto dell'array
          const arrayContent = inheritsMatch[1]
          // Dividi per virgole e rimuovi spazi e virgolette
          const items = arrayContent.split(',').map(item => item.trim().replace(/"/g, ''))
          // Trova il primo elemento non vuoto (di solito il terzo)
          const printerName = items.find(item => item && item !== '')
          
          if (printerName) {
            console.log('üñ®Ô∏è Stampante estratta da inherits_group:', printerName)
            return printerName
          }
        }
      }
      
      // Pattern per PrusaSlicer: "default_print_profile = QUALITY_0.20mm_Nozzle_0.6_VC4_IDEX"
      if (trimmedLine.includes('default_print_profile =')) {
        const profileMatch = trimmedLine.match(/default_print_profile = (.+)/)
        if (profileMatch) {
          const profileName = profileMatch[1].trim()
          // Estrai il nome della stampante dal profilo (es. "VC4_IDEX" da "QUALITY_0.20mm_Nozzle_0.6_VC4_IDEX")
          const printerMatch = profileName.match(/.*_([A-Z0-9_]+)$/)
          if (printerMatch) {
            const printerName = printerMatch[1]
            console.log('üñ®Ô∏è Stampante estratta da default_print_profile:', printerName)
            return printerName
          }
        }
      }
      
      // Pattern per altri slicer: "Printer: Ender 3"
      if (trimmedLine.includes('Printer:') || trimmedLine.includes('printer:')) {
        const printerMatch = trimmedLine.match(/[Pp]rinter:\s*(.+)/)
        if (printerMatch) {
          const printerName = printerMatch[1].trim()
          console.log('üñ®Ô∏è Stampante estratta da Printer:', printerName)
          return printerName
        }
      }
      
      // Pattern per "Generated with PrusaSlicer"
      if (trimmedLine.includes('Generated with PrusaSlicer')) {
        const versionMatch = trimmedLine.match(/Generated with PrusaSlicer\s+([\d.]+)/)
        if (versionMatch) {
          const version = versionMatch[1]
          console.log('üñ®Ô∏è PrusaSlicer versione:', version)
          return `PrusaSlicer ${version}`
        }
      }
      
      // Pattern per "printer_notes:" o "printer_model_id:"
      if (trimmedLine.includes('printer_notes:') || trimmedLine.includes('printer_model_id:')) {
        const notesMatch = trimmedLine.match(/(?:printer_notes|printer_model_id):\s*(.+)/)
        if (notesMatch) {
          const printerName = notesMatch[1].trim()
          console.log('üñ®Ô∏è Stampante estratta da printer_notes/model_id:', printerName)
          return printerName
        }
      }
    }

    return undefined
  }

  private extractLayerHeight(): number | undefined {
    const layerHeightPatterns = [
      /;Layer height: (\d+\.?\d*)/i,
      /;First layer height: (\d+\.?\d*)/i,
      /;Layer height \(mm\): (\d+\.?\d*)/i
    ]

    for (const pattern of layerHeightPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        return parseFloat(match[1])
      }
    }

    return undefined
  }

  private extractInfillPercentage(): number | undefined {
    const infillPatterns = [
      /;Infill density: (\d+\.?\d*)%/i,
      /;Fill density: (\d+\.?\d*)%/i,
      /;Infill: (\d+\.?\d*)%/i
    ]

    for (const pattern of infillPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        return parseFloat(match[1])
      }
    }

    return undefined
  }

  private extractPrintSpeed(): number | undefined {
    const speedPatterns = [
      /;Print speed: (\d+\.?\d*)/i,
      /;Speed: (\d+\.?\d*)/i,
      /;Travel speed: (\d+\.?\d*)/i
    ]

    for (const pattern of speedPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        return parseFloat(match[1])
      }
    }

    return undefined
  }

  private extractBedTemperature(): number | undefined {
    const bedTempPatterns = [
      /;Bed temperature: (\d+\.?\d*)/i,
      /;M140 S(\d+\.?\d*)/i,
      /;M190 S(\d+\.?\d*)/i,
      // Formato BambuStudio - cerca nei commenti di configurazione
      /;bed_temperature_range_high\[0\] = (\d+\.?\d*)/i,
      /;bed_temperature_range_low\[0\] = (\d+\.?\d*)/i
    ]

    for (const pattern of bedTempPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        const temp = parseFloat(match[1])
        // Per BambuStudio, prendi la temperatura alta se disponibile
        if (pattern.source.includes('range_high')) {
          return temp
        } else if (pattern.source.includes('range_low')) {
          return temp
        } else {
          return temp
        }
      }
    }

    return undefined
  }

  private extractNozzleTemperature(): number | undefined {
    const nozzleTempPatterns = [
      /;Nozzle temperature: (\d+\.?\d*)/i,
      /;M104 S(\d+\.?\d*)/i,
      /;M109 S(\d+\.?\d*)/i,
      // Formato BambuStudio - cerca nei commenti di configurazione
      /;nozzle_temperature_range_high\[0\] = (\d+\.?\d*)/i,
      /;nozzle_temperature_range_low\[0\] = (\d+\.?\d*)/i
    ]

    for (const pattern of nozzleTempPatterns) {
      const match = this.content.match(pattern)
      if (match) {
        const temp = parseFloat(match[1])
        // Per BambuStudio, prendi la temperatura alta se disponibile
        if (pattern.source.includes('range_high')) {
          return temp
        } else if (pattern.source.includes('range_low')) {
          return temp
        } else {
          return temp
        }
      }
    }

    // Per BambuStudio, cerca anche nei metadati del file .gcode.3mf
    // Questi valori potrebbero essere estratti dalla funzione extractGcodeMetadata
    return undefined
  }

  private calculateTotalLayers(): number | undefined {
    // Cerca informazioni sui layer
    const layerPatterns = [
      /;LAYER:(\d+)/gi,
      /;Layer count: (\d+)/i,
      /;Total layers: (\d+)/i
    ]

    for (const pattern of layerPatterns) {
      const matches = this.content.match(pattern)
      if (matches) {
        if (pattern.source.includes('LAYER:')) {
          // Conta i layer unici
          const layerNumbers = new Set()
          for (const match of matches) {
            const layerNum = match.match(/(\d+)/)
            if (layerNum) layerNumbers.add(parseInt(layerNum[1]))
          }
          return layerNumbers.size
        } else {
          const match = this.content.match(pattern)
          if (match) {
            return parseInt(match[1])
          }
        }
      }
    }

    return undefined
  }

  private calculatePrintVolume(): number {
    // Stima basata su dimensioni e layer height
    const layerHeight = this.extractLayerHeight() || 0.2
    const totalLayers = this.calculateTotalLayers() || 100
    
    // Stima volume basata su layer height e numero layer
    // Assumiamo un'area di stampa media di 100cm¬≤
    const estimatedArea = 100 // cm¬≤
    const volume = estimatedArea * layerHeight * totalLayers
    
    return Math.round(volume)
  }

  private calculateEstimatedCost(weight: number, material?: string): number {
    // Prezzi per kg di materiale (‚Ç¨)
    const materialPrices: { [key: string]: number } = {
      'PLA': 25,
      'ABS': 20,
      'PETG': 30,
      'TPU': 40,
      'default': 25
    }

    const pricePerKg = materialPrices[material?.toUpperCase() || 'default'] || materialPrices.default
    const weightKg = weight / 1000
    
    return Math.round(weightKg * pricePerKg * 100) / 100 // Arrotonda a 2 decimali
  }

  public getStats(): GcodeStats {
    return this.stats
  }

  public getContent(): string {
    return this.content
  }
}

/**
 * Parsa i metadati XML dal file .gcode.3mf
 */
function parseXmlMetadata(xmlContent: string): GcodeMetadata {
  const metadata: GcodeMetadata = {}
  
  try {
    // Estrai i metadati usando regex per semplicit√†
    // In futuro si potrebbe usare un parser XML pi√π robusto
    
    // Application
    const appMatch = xmlContent.match(/<metadata name="Application">([^<]+)<\/metadata>/)
    if (appMatch) {
      metadata.application = appMatch[1]
    }
    
    // Creation Date
    const dateMatch = xmlContent.match(/<metadata name="CreationDate">([^<]+)<\/metadata>/)
    if (dateMatch) {
      metadata.creation_date = dateMatch[1]
    }
    
    // Designer User ID
    const designerMatch = xmlContent.match(/<metadata name="DesignerUserId">([^<]+)<\/metadata>/)
    if (designerMatch) {
      metadata.designer_user_id = designerMatch[1]
    }
    
    // Verifica se √® BambuStudio
    if (metadata.application?.toLowerCase().includes('bambustudio')) {
      metadata.printer_brand = 'Bambu Lab'
      metadata.printer_model = 'Bambu Studio'
    }
    
    // Estrai informazioni dal nome dell'applicazione
    const appName = metadata.application || ''
    if (appName.toLowerCase().includes('bambu')) {
      metadata.printer_brand = 'Bambu Lab'
    }
    
    return metadata
    
  } catch (error) {
    return {
      error: 'Errore parsing XML',
      raw_xml: xmlContent.substring(0, 500)
    }
  }
}

/**
 * Estrae i metadati da un file .gcode.3mf
 * I file .gcode.3mf sono essenzialmente file ZIP che contengono metadati
 */
export async function extractGcodeMetadata(file: File): Promise<GcodeMetadata> {
  try {
    const zip = new JSZip()
    const zipContent = await zip.loadAsync(file)
    
    const fileNames = Object.keys(zipContent.files)
    
    // Cerca il file di metadati in varie posizioni possibili
    const metadataFiles = [
      'metadata.json',
      'Metadata.json', 
      'metadata.xml',
      'Metadata.xml',
      '3D/3dmodel.model',
      '3D/3dmodel.model/thumbnail.png',
      'Metadata/thumbnail.png',
      'Metadata/metadata.json',
      'Metadata/Metadata.json'
    ]
    
    let metadataContent: string | null = null
    let foundFile: string | null = null
    
    for (const filename of metadataFiles) {
      const metadataFile = zipContent.file(filename)
      if (metadataFile) {
        foundFile = filename
        metadataContent = await metadataFile.async('string')
        break
      }
    }
    
    if (!metadataContent) {
      // Se non troviamo i file standard, cerchiamo qualsiasi file che potrebbe contenere metadati
      for (const fileName of fileNames) {
        if (fileName.toLowerCase().includes('metadata') || 
            fileName.toLowerCase().includes('config') ||
            fileName.toLowerCase().includes('settings') ||
            fileName.toLowerCase().includes('info') ||
            fileName.toLowerCase().includes('model')) {
          const file = zipContent.file(fileName)
          if (file) {
            try {
              const content = await file.async('string')
              
              // Prova a parsare come JSON
              try {
                const jsonContent = JSON.parse(content)
                foundFile = fileName
                metadataContent = content
                break
              } catch {
                // Non √® JSON, potrebbe essere XML
                if (content.trim().startsWith('<?xml') || content.trim().startsWith('<model')) {
                  foundFile = fileName
                  metadataContent = content
                  break
                }
              }
            } catch (err) {
              // Ignora errori di lettura
            }
          }
        }
      }
    }
    
    if (!metadataContent) {
      // Restituisci un oggetto con informazioni di debug
      return {
        debug_files: fileNames.join(', '),
        error: 'Nessun file di metadati trovato nel file .gcode.3mf'
      }
    }
    
    // Prova a parsare come JSON
    try {
      const parsedMetadata = JSON.parse(metadataContent)
      
      // Cerca SEMPRE informazioni aggiuntive in altri file del ZIP
      const additionalInfo = await searchForProfileInfo(zipContent, fileNames)
      
      // Combina le informazioni, dando priorit√† a additionalInfo
      return { ...parsedMetadata, ...additionalInfo }
    } catch (parseError) {
      // Prova a parsare come XML
      if (metadataContent.trim().startsWith('<?xml') || metadataContent.trim().startsWith('<model')) {
        const xmlMetadata = parseXmlMetadata(metadataContent)
        
        // Cerca informazioni aggiuntive in altri file del ZIP
        const additionalInfo = await searchForProfileInfo(zipContent, fileNames)
        
        // Combina le informazioni
        return { ...xmlMetadata, ...additionalInfo }
      }
      
      // Se non √® JSON o XML, restituiamo il contenuto grezzo
      return { 
        raw_metadata: metadataContent,
        source_file: foundFile || undefined,
        error: 'Metadati non in formato JSON o XML riconosciuto'
      }
    }
  } catch (error) {
    throw new Error(`Impossibile estrarre metadati dal file .gcode.3mf: ${error}`)
  }
}

/**
 * Cerca informazioni del profilo di stampa in altri file del ZIP
 */
async function searchForProfileInfo(zipContent: JSZip, fileNames: string[]): Promise<Partial<GcodeMetadata>> {
  const additionalInfo: Partial<GcodeMetadata> = {}
  
  // Cerca PRIMA nel file project_settings.config per il nome della stampante
  const projectSettingsFile = zipContent.file('Metadata/project_settings.config')
  if (projectSettingsFile) {
    console.log('üñ®Ô∏è Prova a leggere project_settings.config')
    try {
      const content = await projectSettingsFile.async('string')
      
      // Cerca il nome della stampante nel campo inherits_group
      const inheritsGroupMatch = content.match(/"inherits_group":\s*\[([^\]]+)\]/)
      if (inheritsGroupMatch) {
        // Estrai il contenuto dell'array
        const arrayContent = inheritsGroupMatch[1]
        // Dividi per virgole e rimuovi spazi e virgolette
        const items = arrayContent.split(',').map(item => item.trim().replace(/"/g, ''))
        // Trova il primo elemento non vuoto (di solito il terzo)
        const printerName = items.find(item => item && item !== '')
        
        if (printerName) {
          additionalInfo.printer_model = printerName
          console.log('üñ®Ô∏è Modello stampante estratto da inherits_group:', printerName)
        }
      }
    } catch (err) {
      console.log('‚ùå Errore lettura project_settings.config:', err)
    }
  }
  
  return additionalInfo
}

/**
 * Verifica se un file G-code √® per una stampante Bambu Lab
 */
export function isBambuLabPrinter(metadata: GcodeMetadata): boolean {
  const printerBrand = metadata.printer_brand?.toLowerCase()
  const printerModel = metadata.printer_model?.toLowerCase()
  const application = metadata.application?.toLowerCase()
  
  return Boolean(
    printerBrand?.includes('bambu') ||
    printerBrand?.includes('bambulab') ||
    printerModel?.includes('bambu') ||
    printerModel?.includes('bambulab') ||
    printerModel?.includes('x1') ||
    printerModel?.includes('p1') ||
    printerModel?.includes('a1') ||
    application?.includes('bambustudio') ||
    application?.includes('bambu')
  )
}

/**
 * Verifica se il profilo di stampa √® automatico
 */
export function isAutomaticProfile(metadata: GcodeMetadata, automaticProfileName: string): boolean {
  // Prima controlla se √® gi√† stato identificato come automatico
  if (metadata.is_automatic_profile === 'true') {
    return true
  }
  
  // Controlla il preset della stampante (printer_settings_id)
  const printerSettingsId = metadata.printer_settings_id?.toLowerCase()
  const automaticProfile = automaticProfileName.toLowerCase()
  
  if (printerSettingsId && printerSettingsId.includes(automaticProfile)) {
    return true
  }
  
  // Fallback: controlla il profilo di stampa
  const printSettingsName = metadata.print_settings_name?.toLowerCase()
  
  return printSettingsName ? printSettingsName.includes(automaticProfile) : false
}

/**
 * Ottiene il nome del materiale dal metadata
 */
export function getMaterialName(metadata: GcodeMetadata): string {
  // Priorit√†: material_type (tipologia) > material_name > Unknown
  return metadata.material_type || metadata.material_name || 'Unknown'
}

/**
 * Ottiene il nome del profilo di stampa dal metadata
 */
export function getPrintSettingsName(metadata: GcodeMetadata): string {
  return metadata.print_settings_name || metadata.print_settings_id || 'Unknown'
} 

// Funzione helper per analizzare un file G-code
export async function analyzeGcodeFile(file: File): Promise<GcodeAnalysis> {
  // Determina il tipo di file basandosi sull'estensione
  const fileName = file.name.toLowerCase()
  
  if (fileName.endsWith('.gcode.3mf')) {
    return analyzeGcode3mfFile(file)
  } else if (fileName.endsWith('.gcode')) {
    return analyzePlainGcodeFile(file)
  } else {
    throw new Error('Tipo di file non supportato. Supportati: .gcode, .gcode.3mf')
  }
}

/**
 * Analizza un file .gcode puro (file di testo ASCII)
 */
export async function analyzePlainGcodeFile(file: File): Promise<GcodeAnalysis> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    
    reader.onload = (e) => {
      try {
        const content = e.target?.result as string
        const parser = new GcodeParser(content)
        const analysis = parser.analyze()
        resolve(analysis)
      } catch (error) {
        reject(error)
      }
    }
    
    reader.onerror = () => {
      reject(new Error('Errore nella lettura del file'))
    }
    
    reader.readAsText(file)
  })
}

/**
 * Analizza un file .gcode.3mf (file ZIP che contiene metadati e G-code)
 */
export async function analyzeGcode3mfFile(file: File): Promise<GcodeAnalysis> {
  try {
    const zip = new JSZip()
    const zipContent = await zip.loadAsync(file)
    
    // Cerca il file G-code all'interno del ZIP
    const gcodeFiles = Object.keys(zipContent.files).filter(name => 
      name.toLowerCase().endsWith('.gcode') && 
      !name.toLowerCase().includes('thumbnail') &&
      !name.toLowerCase().includes('small')
    )
    
    if (gcodeFiles.length === 0) {
      throw new Error('Nessun file G-code trovato nel file .gcode.3mf')
    }
    
    // Prendi il primo file G-code trovato (di solito c'√® solo uno)
    const gcodeFileName = gcodeFiles[0]
    const gcodeFile = zipContent.file(gcodeFileName)
    
    if (!gcodeFile) {
      throw new Error('Impossibile leggere il file G-code dal file .gcode.3mf')
    }
    
    // Leggi il contenuto del file G-code
    const gcodeContent = await gcodeFile.async('string')
    
    // Analizza il contenuto G-code usando il parser esistente
    const parser = new GcodeParser(gcodeContent)
    const analysis = parser.analyze()
    
    // Estrai metadati aggiuntivi dal file .gcode.3mf se disponibili
    const metadata = await extractGcodeMetadata(file)
    
    // Arricchisci l'analisi con i metadati se disponibili
    if (metadata.material_name) {
      analysis.materiale = metadata.material_name
    }
    
    // Estrai il peso dai metadati se disponibile (pi√π accurato)
    const weightFromMetadata = await extractWeightFromGcode3mf(file)
    if (weightFromMetadata !== null) {
      analysis.peso_grammi = weightFromMetadata
      console.log('‚öñÔ∏è Peso aggiornato dai metadati:', weightFromMetadata, 'g')
    }
    
    // Estrai il tempo di stampa dai metadati se disponibile (pi√π accurato)
    const timeFromMetadata = await extractPrintTimeFromGcode3mf(file)
    if (timeFromMetadata !== null) {
      analysis.tempo_stampa_min = timeFromMetadata
      console.log('‚è∞ Tempo aggiornato dai metadati:', timeFromMetadata, 'min')
    }
    
    // Estrai il modello stampante dai metadati - PRIORIT√Ä ASSOLUTA a inherits_group
    if (metadata.printer_model) {
      analysis.stampante = metadata.printer_model
      console.log('üñ®Ô∏è Modello stampante aggiornato dai metadati:', metadata.printer_model)
    }
    
    return analysis
    
  } catch (error) {
    throw new Error(`Errore nell'analisi del file .gcode.3mf: ${error}`)
  }
} 

/**
 * Estrae il peso da un file .gcode.3mf cercando nei metadati
 */
export async function extractWeightFromGcode3mf(file: File): Promise<number | null> {
  try {
    const zip = new JSZip()
    const zipContent = await zip.loadAsync(file)
    
    // Cerca il peso nel file plate_1.json
    const plateFile = zipContent.file('Metadata/plate_1.json')
    if (plateFile) {
      const content = await plateFile.async('string')
      
      // Cerca il campo weight nei metadati
      const weightMatch = content.match(/"weight":\s*([0-9.]+)/)
      if (weightMatch) {
        const weight = parseFloat(weightMatch[1])
        console.log('‚öñÔ∏è Peso estratto da plate_1.json:', weight, 'g')
        return Math.round(weight)
      }
    }
    
    // Cerca anche in altri file di metadati
    const metadataFiles = [
      'Metadata/slice_info.config',
      'Metadata/project_settings.config',
      'Metadata/model_settings.config'
    ]
    
    for (const fileName of metadataFiles) {
      const file = zipContent.file(fileName)
      if (file) {
        const content = await file.async('string')
        
        // Cerca il campo weight
        const weightMatch = content.match(/weight[:\s]+([0-9.]+)/i)
        if (weightMatch) {
          const weight = parseFloat(weightMatch[1])
          console.log('‚öñÔ∏è Peso estratto da', fileName, ':', weight, 'g')
          return Math.round(weight)
        }
      }
    }
    
    return null
  } catch (error) {
    console.error('Errore nell\'estrazione del peso da .gcode.3mf:', error)
    return null
  }
} 

/**
 * Estrae il tempo di stampa da un file .gcode.3mf cercando nei metadati
 */
export async function extractPrintTimeFromGcode3mf(file: File): Promise<number | null> {
  try {
    const zip = new JSZip()
    const zipContent = await zip.loadAsync(file)
    
    // Cerca il tempo nel file plate_1.json
    const plateFile = zipContent.file('Metadata/plate_1.json')
    if (plateFile) {
      const content = await plateFile.async('string')
      
      // Cerca il campo print_time nei metadati
      const timeMatch = content.match(/"print_time":\s*([0-9.]+)/)
      if (timeMatch) {
        const timeSeconds = parseFloat(timeMatch[1])
        const timeMinutes = Math.round(timeSeconds / 60)
        console.log('‚è∞ Tempo estratto da plate_1.json:', timeSeconds, 's ->', timeMinutes, 'min')
        return timeMinutes
      }
    }
    
    // Cerca anche in altri file di metadati
    const metadataFiles = [
      'Metadata/slice_info.config',
      'Metadata/project_settings.config',
      'Metadata/model_settings.config'
    ]
    
    for (const fileName of metadataFiles) {
      const file = zipContent.file(fileName)
      if (file) {
        const content = await file.async('string')
        
        // Cerca il campo print_time o estimated_time
        const timeMatch = content.match(/(print_time|estimated_time)[:\s]+([0-9.]+)/i)
        if (timeMatch) {
          const timeSeconds = parseFloat(timeMatch[2])
          const timeMinutes = Math.round(timeSeconds / 60)
          console.log('‚è∞ Tempo estratto da', fileName, ':', timeSeconds, 's ->', timeMinutes, 'min')
          return timeMinutes
        }
      }
    }
    
    return null
  } catch (error) {
    console.error('Errore nell\'estrazione del tempo da .gcode.3mf:', error)
    return null
  }
} 